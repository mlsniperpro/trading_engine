"""
Signal pipeline data structures for the decision engine.

This module defines the core data structures used in signal generation:
- SignalResult: Output from primary analyzers
- TradeSignal: Final trading signal with confluence score
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional


@dataclass
class SignalResult:
    """
    Result from a primary signal analyzer.

    Primary analyzers return pass/fail with strength and reasoning.
    ALL primary analyzers must pass for signal generation to continue.
    """
    passed: bool
    strength: float  # 0.0 to 1.0
    reason: str
    direction: Optional[str] = None  # 'long' or 'short' or None
    metadata: Dict = field(default_factory=dict)

    def __repr__(self) -> str:
        status = "✅ PASS" if self.passed else "❌ FAIL"
        return f"SignalResult({status}, strength={self.strength:.2f}, {self.reason})"


@dataclass
class TradeSignal:
    """
    Final trading signal generated by the decision engine.

    This is emitted when:
    1. ALL primary analyzers pass
    2. Confluence score >= threshold
    """
    symbol: str
    side: str  # 'long' or 'short'
    confluence_score: float
    primary_signals: List[SignalResult]
    filter_scores: Dict[str, float]
    timestamp: datetime
    entry_price: Optional[float] = None
    confidence: Optional[str] = None  # 'low', 'medium', 'high', 'very_high'

    def __post_init__(self):
        """Calculate confidence level based on confluence score."""
        if self.confidence is None:
            if self.confluence_score >= 7.0:
                self.confidence = 'very_high'
            elif self.confluence_score >= 5.0:
                self.confidence = 'high'
            elif self.confluence_score >= 4.0:
                self.confidence = 'medium'
            else:
                self.confidence = 'low'

    def __repr__(self) -> str:
        return (
            f"TradeSignal({self.symbol}, {self.side.upper()}, "
            f"confluence={self.confluence_score:.1f}/10.0, "
            f"confidence={self.confidence})"
        )

    def to_dict(self) -> Dict:
        """Convert to dictionary for event emission."""
        return {
            'symbol': self.symbol,
            'side': self.side,
            'confluence_score': self.confluence_score,
            'confidence': self.confidence,
            'entry_price': self.entry_price,
            'timestamp': self.timestamp.isoformat(),
            'primary_signals': [
                {
                    'analyzer': type(sig).__name__ if hasattr(sig, '__class__') else 'Unknown',
                    'passed': sig.passed,
                    'strength': sig.strength,
                    'reason': sig.reason,
                    'direction': sig.direction
                }
                for sig in self.primary_signals
            ],
            'filter_scores': self.filter_scores
        }
